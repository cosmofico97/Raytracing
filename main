#!/usr/bin/env julia

# The MIT License (MIT)
#
# Copyright © 2021 Matteo Foglieni and Riccardo Gervasoni
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the “Software”), to deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of
# the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
# LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
# SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.


using Pkg
Pkg.activate(normpath(@__DIR__))

using Colors, Images, ImageIO, ArgParse
using ColorTypes:RGB
import FileIO: @format_str, query
using Raytracing

FILE_NAME = split(PROGRAM_FILE, "/")[end]

function parse_commandline_error_handler(settings::ArgParseSettings, err, err_code::Int = 1)

    if occursin("no command given", err.text)

        println("\nERROR: no input command were given.\n"*
                "execute in one of the following ways to get the help instructions:\n"*
                "\t- from the CLI: \t\tjulia $(FILE_NAME) --help\n"*
                "\t- from the CLI: \t\t./$FILE_NAME --help\n"*
                "\t- inside the Julia REPL: \tinclude(\"$(FILE_NAME) --help\n" 
                )
        
    elseif occursin("out of range input for input_file:", err.text)
        println(stderr, "input_file is not a PFM file")
    else
        println(stderr, err.text, usage_string(settings))
    end

    exit(err_code)
end

function ArgParse_command_line(arguments)
    s = ArgParseSettings()
    s.description = "Raytracing for the generation of photorealistic images in Julia."
    s.exc_handler = parse_commandline_error_handler
    #s.version = @project_version
    s.version = "0.1.0"
    @add_arg_table! s begin
        "demo"
            action = :command
            help = "create a standard image that checks the correct behaviour of the program."
        "tonemapping"
            action = :command
            help = "apply tone mapping to a pfm image and save it to file"
    end

    s["demo"].description = "creates a demo.png and a demo.pfm files of 10 white spheres on a dark backgroud."*
                            "8 spheres are placed at the 8 vertexes of a cube, 1 in the middle "*
                            "of the left face and the last in the lower one."*
                            "Execute it and check the correct placement of the spheres."

    s["tonemapping"].description = "Apply tone mapping to a pfm image and save it to file."
    add_arg_group!(s["tonemapping"], "tonemapping settings");
    @add_arg_table! s["tonemapping"] begin
        "--alpha", "-a"
            help = "scaling factor for the normalization process"
            arg_type = Float64
            default = 0.5
        "--gamma", "-g"
            help = "gamma value for the tone mapping process"
            arg_type = Float64
            default = 1.
    end
    add_arg_group!(s["tonemapping"], "files");
    @add_arg_table! s["tonemapping"] begin
        "input_file"
            help = "path to input file, it must be a PFM file"
            range_tester = input -> (typeof(query(input))<:File{format"PFM"})
            required = true
        "output_file"
            help = "output file name"
            required = true
    end
    
    parse_args(arguments, s)
end



function main(args)
	parsed_arguments = ArgParse_command_line(args) # the result is a Dict{String,Any}
	parsed_command = parsed_arguments["%COMMAND%"]
	parsed_args = parsed_arguments[parsed_command]

	println("parsed_command : ", parsed_command)
	println("parsed_arguments : ", parsed_args)

	println("typeof parsed_arguments : ", typeof(parsed_arguments))
	println("Parsed args:")
	for (key,val) in parsed_arguments
		println("  $key  =>  $(repr(val))")
	end

	return nothing
end


main(ARGS)