<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Base Structs · Raytracer.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Raytracer.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../demo/">Demo</a></li><li><a class="tocitem" href="../demo_animation/">Demo animation</a></li><li class="is-active"><a class="tocitem" href>Base Structs</a></li><li><a class="tocitem" href="../readingwritingpfm/">Reading and Writing PFM files</a></li><li><a class="tocitem" href="../brdfs_and_pigments/">BRDFs and Pigments</a></li><li><a class="tocitem" href="../cameras/">Cameras</a></li><li><a class="tocitem" href="../tone_mapping/">Tone Mapping</a></li><li><a class="tocitem" href="../renderers/">Renderers</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../shapes/">Avaiable Shapes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Base Structs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Base Structs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cosmofico97/Raytracing/blob/master/docs/src/base_structs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Base-Structs-and-functions-of-the-program"><a class="docs-heading-anchor" href="#Base-Structs-and-functions-of-the-program">Base Structs and functions of the program</a><a id="Base-Structs-and-functions-of-the-program-1"></a><a class="docs-heading-anchor-permalink" href="#Base-Structs-and-functions-of-the-program" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Raytracing.HDRimage" href="#Raytracing.HDRimage"><code>Raytracing.HDRimage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HDRimage(
    width::Int64
    height::Int64
    rgb_m::Array{RGB{Float32}} = fill(RGB(0.0, 0.0, 0.0), (width*height,))
    )</code></pre><p>Define a image in the format 2D  High-Dynamic-Range.</p><p><strong>Arguments</strong></p><ul><li><p><code>width::Float64</code> : width pixel number of the image</p></li><li><p><code>height::Float64</code> : height pixel number of the image</p></li><li><p><code>rgb_m::Array{RGB{Float32}}</code> : linearized color matrix;  the first element is the one in the bottom-left of the matrix,  then the line is read left-to-right and going to the upper row.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L25-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.to_RGB" href="#Raytracing.to_RGB"><code>Raytracing.to_RGB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_RGB(r::Int64, g::Int64, b::Int64) :: RGB{Float32}</code></pre><p>Return the RGB color with values inside the <code>[0,1]</code> interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.get_matrix" href="#Raytracing.get_matrix"><code>Raytracing.get_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_matrix(img::HDRimage) :: Matrix{RGB{Float32}}</code></pre><p>Return the color matrix of the input <code>img</code>. The order of the pixel as they are stored in the <code>HDRimage</code> format is corrected in order to get the &quot;natural&quot; pixel matrix. </p><p>See also: <a href="#Raytracing.HDRimage"><code>HDRimage</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Parameters" href="#Raytracing.Parameters"><code>Raytracing.Parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Parameters(
    infile::String, 
    outfile::String,
    a::Float64 = 0.18,
    γ::Float64 = 1.0
    )</code></pre><p>Parameters passed from command line for the tone mapping.</p><p><strong>Arguments</strong></p><ul><li><p><code>infile::String</code> : input file name (must be a pfm)</p></li><li><p><code>outfile::String</code> : output file name (must be a png)</p></li><li><p><code>a::Float64</code> : parameter a for luminosity correction</p></li><li><p><code>γ::Float64</code> : parameter γ for screen correction</p></li></ul><p>See also: <a href="../tone_mapping/#Raytracing.tone_mapping"><code>tone_mapping</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L73-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Point" href="#Raytracing.Point"><code>Raytracing.Point</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Point(x::Float64, y::Float64, z::Float64)</code></pre><p>A point in 3D space.</p><p><strong>Constructors</strong></p><ul><li><p><code>Point() = new(0., 0. ,0.)</code></p></li><li><p><code>Point(x, y, z) = new(x, y, z)</code></p></li><li><p><code>Point(v::SVector{4, Float64}) = new(v[1], v[2], v[3])</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L107-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Vec" href="#Raytracing.Vec"><code>Raytracing.Vec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Vec(x::Float64, y::Float64, z::Float64)</code></pre><p>A 3D Vector</p><p><strong>Constructors</strong></p><ul><li><p><code>Vec() = new(0., 0. ,0.)</code></p></li><li><p><code>Vec(x, y, z) = new(x, y, z)</code></p></li><li><p><code>Vec(P::Point) = new(P.x, P.y, P.z)</code></p></li><li><p><code>Vec(v::SVector{4, Float64}) = new(v[1], v[2], v[3])</code></p></li><li><p><code>Vec(N::Normal) = Vec(N.x, N.y, N.z)</code></p></li></ul><p>See also: <a href="#Raytracing.Normal"><code>Normal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L129-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Normal" href="#Raytracing.Normal"><code>Raytracing.Normal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Normal(x::Float64, y::Float64, z::Float64)</code></pre><p>A normal vector in 3D space, you can give three components  and its struct normalize them.</p><p><strong>Constructors</strong></p><ul><li><p><code>Normal(x,y,z) = new(x, y ,z)</code></p></li><li><p><code>Normal(v::Vec) = new(v[1]/m, v[2]/m, v[3]/m)</code></p></li><li><p><code>Normal(v::Vector{Float64}) = new(v[1]/m, v[2]/m, v[3]/m)</code></p></li><li><p><code>Normal(v::SVector{4,Float64}) = new(v[1]/m, v[2]/m, v[3]/m)</code></p></li></ul><p>(<code>m</code> indicates the norm of the input vector)</p><p>See also: <a href="#Raytracing.Vec"><code>Vec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L162-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Transformation" href="#Raytracing.Transformation"><code>Raytracing.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Transformation(M::SMatrix{4,4,Float64}, invM::SMatrix{4,4,Float64})</code></pre><p>Contain two matrices 4x4 of <code>Float64</code>, one the inverse of the other. It&#39;s used to implement rotations, scaling and translations in 3D space  with homogenous formalism.</p><p><strong>NOTE</strong>: It does not check if <code>invM</code> is the inverse matrix of <code>M</code>, for computational efficiency purposes! In order to do that, looks at <code>is_consistent(T::Transformation)</code> function.</p><p><strong>Constructors</strong></p><ul><li><p><code>Transformation(m, invm) = new(m, invm)</code></p></li><li><p><code>Transformation() = new(            SMatrix{4,4}( Diagonal(ones(4)) ),             SMatrix{4,4}( Diagonal(ones(4)) )        )</code></p></li></ul><p>See also: <a href="../transformations/#Raytracing.is_consistent"><code>is_consistent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L210-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Ray" href="#Raytracing.Ray"><code>Raytracing.Ray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ray(
    origin::Point,
    dir::Vec,
    tmin::Float64 = 1e-5,
    tmax::Float64 = Inf,
    depth::Int64 = 0,
    )</code></pre><p>A ray of light propagating in space.</p><p><strong>Arguments</strong></p><ul><li><p><code>origin::Point</code> : origin of the ray</p></li><li><p><code>dir::Vec</code> : 3D direction along which this ray propagates</p></li><li><p><code>tmin::Float64</code> : minimum distance travelled by the ray is this number times <code>dir</code></p></li><li><p><code>tmax::Float64</code> : maximum distance travelled by the ray is this number times <code>dir</code></p></li><li><p><code>depth::Int64</code> : number of times this ray was reflected/refracted</p></li></ul><p>See also: <a href="#Raytracing.Point"><code>Point</code></a>, <a href="#Raytracing.Vec"><code>Vec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L248-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.at" href="#Raytracing.at"><code>Raytracing.at</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">at(r::Ray, t::Float64) :: Point</code></pre><p>Compute the point along the ray&#39;s path at some distance from the origin.</p><p>Return a <a href="#Raytracing.Point"><code>Point</code></a> object representing the point in 3D space whose distance from the ray&#39;s origin is equal to <code>t</code>, measured in units of the length of <code>Vec.dir</code>.</p><p>See also: <a href="#Raytracing.Ray"><code>Ray</code></a>, <a href="#Raytracing.Point"><code>Point</code></a>, <a href="#Raytracing.Vec"><code>Vec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/ImageTracer.jl#L9-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Camera" href="#Raytracing.Camera"><code>Raytracing.Camera</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Camera end</code></pre><p>An abstract type with the following concrete sub-types, defining different types of perspective projections:</p><ul><li><p><a href="../cameras/#Raytracing.OrthogonalCamera"><code>OrthogonalCamera</code></a></p></li><li><p><a href="../cameras/#Raytracing.PerspectiveCamera"><code>PerspectiveCamera</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L286-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.fire_ray" href="#Raytracing.fire_ray"><code>Raytracing.fire_ray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fire_ray(Ocam::OrthogonalCamera, u::Float64, v::Float64) :: Ray
fire_ray(Pcam::PerspectiveCamera, u::Float64, v::Float64) :: Ray
fire_ray(
        ImTr::ImageTracer, 
        col::Int64, row::Int64, 
        u_px::Float64=0.5, v_px::Float64=0.5
    ) :: Ray</code></pre><p>Shoot one light <code>Ray</code> through the pixel (<code>col</code>, <code>row</code>) of <code>ImTr.img</code> image.  The parameters (<code>col</code>, <code>row</code>) are measured in a diffetent way compared to the <code>HDRimage</code> struct: here, the bottom left corner is placed at <code>(0, 0)</code>. The following diagram shows the convenction for an image with dimensions (<code>w</code>,<code>h</code>):</p><pre><code class="language-ditaa">| (h,0)  (h,1)  (h,2)  ...  (h,w) |
|  ...    ...    ...   ...   ...  |
| (1,0)  (1,1)  (1,2)  ...  (1,w) |
| (0,0)  (0,1)  (0,2)  ...  (0,w) |</code></pre><p>The optional values <code>u_px</code> and <code>v_px</code> specify where the ray should cross the pixel; the convenction for their values are represented in the following  diagram as <code>(u_px, v_px)</code>:</p><pre><code class="language-ditaa">(0, 1)                          (1, 1)
    +------------------------------+
    |                              |
    |                              |
    |                              |
    +------------------------------+
(0, 0)                          (1, 0)</code></pre><p>See also: <a href="../cameras/#Raytracing.OrthogonalCamera"><code>OrthogonalCamera</code></a>, <a href="../cameras/#Raytracing.PerspectiveCamera"><code>PerspectiveCamera</code></a>, <a href="#Raytracing.Ray"><code>Ray</code></a>, <a href="#Raytracing.HDRimage"><code>HDRimage</code></a>, <a href="#Raytracing.ImageTracer"><code>ImageTracer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/ImageTracer.jl#L45-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.ImageTracer" href="#Raytracing.ImageTracer"><code>Raytracing.ImageTracer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImageTracer(
    img::HDRimage,
    cam::Camera,
    samples_per_side::Int64 = 0,
    pcg::PCG = PCG()
    )</code></pre><p>Implement the &quot;screen&quot; of the observer.</p><p>Trace an image by shooting light rays through each of its pixels.</p><p><strong>Arguments</strong></p><ul><li><p><code>img::HDRimage</code> : the image that will be rendered (required)</p></li><li><p><code>cam::Camera</code> : camera type of the observer (required)</p></li><li><p><code>samples_per_side::Int64 = 0</code> : if it is larger than zero, stratified sampling will  be applied to each pixel in the image, using the random number generator  <code>pcg</code>; if not, antialiasing will be ignored in <code>fire_all_rays!</code></p></li><li><p><code>pcg::PCG = PCG()</code> : PCG random number generator</p></li></ul><p>See also: <a href="#Raytracing.HDRimage"><code>HDRimage</code></a>,<a href="#Raytracing.Camera"><code>Camera</code></a>, <a href="#Raytracing.PCG"><code>PCG</code></a>, <a href="#Raytracing.fire_ray"><code>fire_ray</code></a>, <a href="#Raytracing.fire_all_rays!"><code>fire_all_rays!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L357-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.fire_all_rays!" href="#Raytracing.fire_all_rays!"><code>Raytracing.fire_all_rays!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fire_all_rays!(
        ImTr::ImageTracer, 
        func::Function, 
        callback::Union{Nothing, Function} = nothing,
        callback_time_s::Float64 = 2.,
        callback_kwargs::String
        )</code></pre><p>Shoot several light rays crossing each of the pixels in the <code>ImTr.img</code> image.</p><p>For each pixel in the <code>HDRimage</code> object fire one <code>Ray</code>, and pass it  to the function <code>func</code>, which must:</p><ul><li>accept a <code>Ray</code> as its only parameter </li><li>return a <code>RGB{Float32}</code> color instance telling the color to  assign to that pixel in the image.</li></ul><p>If <code>callback</code> is not <code>nothing</code>, it must be a function accepting at least two  parameters named <code>col</code> and <code>row</code>. This function is called periodically during the rendering, and the two mandatory  arguments are the row and column number of the last pixel that has been traced. </p><p><em><strong>Pay Attention</strong></em>: Both the row and column are increased by one starting from zero: first the row and then the column.</p><p>The time between two consecutive calls to the callback can be tuned using the  parameter <code>callback_time_s</code>. Any keyword argument passed to <code>fire_all_rays</code>  is passed to the callback.</p><p>See also: <a href="#Raytracing.Ray"><code>Ray</code></a>, <a href="#Raytracing.HDRimage"><code>HDRimage</code></a>, <a href="#Raytracing.ImageTracer"><code>ImageTracer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/ImageTracer.jl#L85-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Pigment" href="#Raytracing.Pigment"><code>Raytracing.Pigment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Pigment end</code></pre><p>This abstract class represents a pigment, i.e., a function that associates  a color with each point on a parametric surface (u,v). Call the function <code>get_color</code> to retrieve the color of the surface given a <code>Vec2d</code> object.</p><p>The concrete sub-types of this abstract class are:</p><ul><li><p><a href="../brdfs_and_pigments/#Raytracing.UniformPigment"><code>UniformPigment</code></a></p></li><li><p><a href="../brdfs_and_pigments/#Raytracing.CheckeredPigment"><code>CheckeredPigment</code></a></p></li><li><p><a href="../brdfs_and_pigments/#Raytracing.ImagePigment"><code>ImagePigment</code></a></p></li></ul><p>See also: <a href="#Raytracing.Vec2d"><code>Vec2d</code></a>, <a href="@ref"><code>get_color</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L399-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.BRDF" href="#Raytracing.BRDF"><code>Raytracing.BRDF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type BRDF end</code></pre><p>An abstract class representing a Bidirectional Reflectance Distribution Function. The concrete sub-types of this abstract class are:</p><ul><li><p><a href="../brdfs_and_pigments/#Raytracing.DiffuseBRDF"><code>DiffuseBRDF</code></a></p></li><li><p><a href="../brdfs_and_pigments/#Raytracing.SpecularBRDF"><code>SpecularBRDF</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L473-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Material" href="#Raytracing.Material"><code>Raytracing.Material</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Material(
    brdf::BRDF = DiffuseBRDF(),
    emitted_radiance::Pigment = UniformPigment()
)</code></pre><p>A struct representing a material.</p><p>See also: <a href="#Raytracing.BRDF"><code>BRDF</code></a>, <a href="../brdfs_and_pigments/#Raytracing.DiffuseBRDF"><code>DiffuseBRDF</code></a>,  <a href="#Raytracing.Pigment"><code>Pigment</code></a>, <a href="../brdfs_and_pigments/#Raytracing.UniformPigment"><code>UniformPigment</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L517-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Shape" href="#Raytracing.Shape"><code>Raytracing.Shape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Shape end</code></pre><p>An abstract type with the following concrete sub-types, defining different types of shapes that can be created:</p><ul><li><p><a href="../shapes/#Raytracing.Sphere"><code>Sphere</code></a></p></li><li><p><a href="../shapes/#Raytracing.Plane"><code>Plane</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L538-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.Vec2d" href="#Raytracing.Vec2d"><code>Raytracing.Vec2d</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Vec2d(u::Float64, v::Float64)</code></pre><p>A 2D vector used to represent a point on a surface. The fields are named <code>u</code> and <code>v</code> to distinguish them from the usual 3D coordinates <code>x</code>, <code>y</code>, <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L650-L656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.HitRecord" href="#Raytracing.HitRecord"><code>Raytracing.HitRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HitRecord(
    world_point::Point,
    normal::Normal,
    surface_point::Vec2d,
    t::Float64,
    ray::Ray,
    shape::Union{Shape, Nothing} = nothing
    )</code></pre><p>A struct holding information about a ray-shape intersection.</p><p><strong>Arguments</strong></p><ul><li><p><code>world_point::Point</code>: world coordinates of the hit point</p></li><li><p><code>normal::Normal</code>: orientation of the normal to the surface where the hit happened</p></li><li><p><code>surface_point::Vec2d</code> : position of the hit point on the surface of the object</p></li><li><p><code>t::Float64</code> : distance from the origin of the ray where the hit happened</p></li><li><p><code>ray::Ray</code> : the <code>ray</code> that hit the surface</p></li><li><p><code>shape::Union{Shape, Nothing}</code>: shape on which the hit happened, or <code>nothing</code> if no intersection happened</p></li></ul><p>See also: <a href="#Raytracing.Point"><code>Point</code></a>, <a href="#Raytracing.Normal"><code>Normal</code></a>, <a href="#Raytracing.Vec2d"><code>Vec2d</code></a> <a href="#Raytracing.Ray"><code>Ray</code></a>, <a href="#Raytracing.Shape"><code>Shape</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L662-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.PointLight" href="#Raytracing.PointLight"><code>Raytracing.PointLight</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointLight(p::Point, c::Color, r::Float64 = 0.0)</code></pre><p>A point light (used by the point-light renderer). This class holds information about a point light (a Dirac&#39;s delta in the  rendering equation).</p><p><strong>Arguments</strong></p><ul><li><p><code>position::Point</code> : position of the point light in 3D space</p></li><li><p><code>color::RGB{Float32}</code> : color of the point light</p></li><li><p><code>linear_radius::Float64</code>: if non-zero, this «linear radius» <code>r</code> is  used to compute the solid angle subtended by the light at a given  distance <code>d</code> through the formula <span>$(r / d)^2$</span>.</p></li></ul><p>See also: <a href="#Raytracing.Point"><code>Point</code></a>, <a href="../renderers/#Raytracing.PointLightRenderer"><code>PointLightRenderer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L703-L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.World" href="#Raytracing.World"><code>Raytracing.World</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">World(
    shapes::Array{Shape} = Array{Shape,1}(),
    point_lights::Array{PointLight} = Array{PointLight,1}()
)</code></pre><p>A struct holding a list of shapes, which make a «world».</p><p>You can add shapes to a world using <code>add_shape!</code>, and call  <code>ray_intersection</code> to check whether a light ray intersects any of  the shapes in the world.</p><p>For the <code>PointLightRenderer</code> algorithm, you can also add point-lights source using <code>add_light!</code>, and <code>world</code> will keep a list of all of them.</p><p>See also: <a href="#Raytracing.Shape"><code>Shape</code></a>, <a href="#Raytracing.add_shape!"><code>add_shape!</code></a>, <a href="#Raytracing.PointLight"><code>PointLight</code></a>, <a href="@ref"><code>add_light</code></a>, <a href="../renderers/#Raytracing.PointLightRenderer"><code>PointLightRenderer</code></a> <a href="../shapes/#Raytracing.ray_intersection-Tuple{Sphere,Ray}"><code>ray_intersection</code></a>, <a href="#Raytracing.Ray"><code>Ray</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Structs.jl#L729-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.add_shape!" href="#Raytracing.add_shape!"><code>Raytracing.add_shape!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_shape!(world::World, shape::Shape)</code></pre><p>Append a new <code>shape</code> to the given <code>world</code>.</p><p>See also: <a href="#Raytracing.Shape"><code>Shape</code></a>, <a href="#Raytracing.World"><code>World</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Shapes.jl#L277-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.add_light!" href="#Raytracing.add_light!"><code>Raytracing.add_light!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_light!(world::World, pointlight::PointLight)</code></pre><p>Append a new <code>pointlight</code> to the given <code>world</code>.</p><p>See also: <a href="#Raytracing.PointLight"><code>PointLight</code></a>, <a href="#Raytracing.World"><code>World</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/Shapes.jl#L290-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.PCG" href="#Raytracing.PCG"><code>Raytracing.PCG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> PCG(state::UInt64 = UInt64(42), inc::UInt64 = UInt64(54))</code></pre><p>A mutable struct for the PCG Uniform Pseudo-random Number Generator.</p><p><strong>Parameters</strong></p><ul><li><code>state::UInt64 = UInt64(42)</code> : initial state number</li><li><code>inc::UInt64 = UInt64(54)</code> : initial sequence number</li></ul><p><strong>References</strong></p><p>Melissa E. O’Neill (2014), <a href="https://www.pcg-random.org/paper.html">&quot;PCG: A Family of Simple Fast  Space-Efficient Statistically Good Algorithms  for Random Number Generation&quot;</a></p><p>See also: <a href="#Raytracing.random"><code>random(pcg::PCG, ::Type{UInt32})</code></a>,  <a href="#Raytracing.random"><code>random(pcg::PCG, ::Type{Float64})</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/PCG.jl#L8-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.random" href="#Raytracing.random"><code>Raytracing.random</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> random(pcg::PCG, ::Type{UInt32}) :: UInt32</code></pre><p>Return a new random UInt32 number and advance PCG&#39;s internal state.</p><p>This function is based on the paper of Melissa E. O’Neill (2014),  where the Permuted Congruential Generator (PCG) family of random  number generators is defined and explained.</p><p><strong>References</strong></p><p>Melissa E. O’Neill (2014), <a href="https://www.pcg-random.org/paper.html">&quot;PCG: A Family of Simple Fast  Space-Efficient Statistically Good Algorithms  for Random Number Generation&quot;</a></p><p>See also: <a href="#Raytracing.random"><code>random(pcg::PCG, ::Type{Float64})</code></a>, <a href="#Raytracing.PCG"><code>PCG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/PCG.jl#L45-L61">source</a></section><section><div><pre><code class="language-none"> random(pcg::PCG, ::Type{Float64}) :: Float64</code></pre><p>Returns a <code>Float64</code> random number inside <code>[0,1]</code> interval obtained  with a PCG Uniform Pseudo-random Number Generator.</p><p>It calls the <code>random(pcg::PCG, ::Type{UInt32})</code> function, which returns a <code>UInt32</code> random number, and divides it with <code>typemax(UInt32)</code>.</p><p>See also: <a href="#Raytracing.random"><code>random(pcg::PCG, ::Type{UInt32})</code></a>, <a href="#Raytracing.PCG"><code>PCG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/PCG.jl#L79-L89">source</a></section><section><div><pre><code class="language-none"> random(pcg::PCG) :: Float64</code></pre><p>Returns a <code>Float64</code> random number inside <code>[0,1]</code> interval obtained  with a PCG Uniform Pseudo-random Number Generator.</p><p>It calls the <code>random(pcg::PCG, ::Type{Float64})</code> function.</p><p>See also: <a href="#Raytracing.random"><code>random(pcg::PCG, ::Type{Float64})</code></a>, <a href="#Raytracing.random"><code>random(pcg::PCG, ::Type{UInt32})</code></a>, <a href="#Raytracing.PCG"><code>PCG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/PCG.jl#L92-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.create_onb_from_z" href="#Raytracing.create_onb_from_z"><code>Raytracing.create_onb_from_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_onb_from_z(normal::Union{Vec, Normal}) :: (Normal, Normal, Normal)</code></pre><p>Return an orthonormal base of 3 <code>Normal</code>s with the z-axes  (i.e. the third <code>Normal</code> returned) parallel to the  input <code>Vec</code>/ <code>Normal</code>.</p><p>The implementation of this function is based on the paper of Duff et al. (2017), which improved the already efficient work made by Frisvad (2012).</p><p><strong>References</strong></p><ul><li><p>Duff et al. (2017), <a href="https://graphics.pixar.com/library/OrthonormalB/paper.pdf">&quot;Building an Orthonormal Basis,  Revisited&quot;</a></p></li><li><p>Frisvad (2012), <a href="https://backend.orbit.dtu.dk/ws/portalfiles/portal/126824972/onb_frisvad_jgt2012_v2.pdf">&quot;Building an Orthonormal Basis from a 3D  Unit Vector Without Normalization&quot;</a></p></li></ul><p>See also: <a href="#Raytracing.Vec"><code>Vec</code></a>, <a href="#Raytracing.Normal"><code>Normal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/OrthoNormalBasis.jl#L8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracing.scatter_ray" href="#Raytracing.scatter_ray"><code>Raytracing.scatter_ray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scatter_ray(
    ::Type{DiffuseBRDF},
    pcg::PCG, 
    incoming_dir::Vec, 
    interaction_point::Point, 
    normal::Normal, 
    depth::Int64,
    ) :: Ray</code></pre><p>Return a <code>Ray</code> scattered by a material with a <code>DiffuseBRDF</code>.</p><p>A <code>DiffuseBRDF</code> has a uniform BRDF, i.e.  <span>$f_r(\mathbf{x}, \mathbf{\Psi}\rightarrow\mathbf{\Theta}) = \rho_d / \pi$</span>; the importance sampling for the <code>PathTracer</code> algorithm use consequently the  following PDF:</p><p class="math-container">\[p(\omega) \propto 
    f_r(\mathbf{x}, \mathbf{\Psi}\rightarrow\mathbf{\Theta}) \, \cos(\vartheta)
    = \frac{\rho_d}{\pi} \, \cos(\vartheta) 
    \propto \cos(\vartheta)\]</p><p class="math-container">\[    \Rightarrow \quad
p(\omega) = \frac{\cos(\vartheta)}{\pi} 
    \quad \Rightarrow \quad
p(\vartheta ,\varphi) = \frac{\cos(\vartheta) \, \sin(\vartheta) }{2\pi}\]</p><p class="math-container">\[\Rightarrow \quad
\begin{aligned}
    &amp;p(\vartheta) = 2 \, \cos(\vartheta) \, \sin(\vartheta) \\
    &amp;p(\varphi | \vartheta) = \frac{1}{2 \pi}
\end{aligned}\]</p><p>See also: <a href="../brdfs_and_pigments/#Raytracing.DiffuseBRDF"><code>DiffuseBRDF</code></a>, <a href="#Raytracing.Ray"><code>Ray</code></a>, <a href="#Raytracing.Vec"><code>Vec</code></a>,  <a href="#Raytracing.Point"><code>Point</code></a>, <a href="#Raytracing.Normal"><code>Normal</code></a>, <a href="#Raytracing.PCG"><code>PCG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/ScatterRay.jl#L8-L47">source</a></section><section><div><pre><code class="language-none">scatter_ray(
    ::Type{SpecularBRDF},
    pcg::PCG, 
    incoming_dir::Vec, 
    interaction_point::Point, 
    normal::Normal, 
    depth::Int64,
    ) :: Ray</code></pre><p>Return a <code>Ray</code> scattered by a material with a <code>SpecularBRDF</code>.</p><p>A <code>SpecularBRDF</code> has a Dirac delta BRDF, i.e.:</p><p class="math-container">\[f_r(\mathbf{x}, \mathbf{\Psi} \rightarrow \mathbf{\Theta}) 
    \propto 
\frac{\delta(\sin^2\theta_r - \sin^2\theta) \, 
    \delta(\psi_r \pm \pi - \psi)}{\cos\theta},\]</p><p>The importance sampling for the <code>PathTracer</code> algorithm use consequently the  following PDF:</p><p class="math-container">\[p(\omega) \propto 
    f_r(\mathbf{x}, \mathbf{\Psi}\rightarrow\mathbf{\Theta}) \, \cos(\vartheta)
    \propto \frac{1}{\cos(\vartheta)} \, \cos(\vartheta) 
    \propto cost\]</p><p>See also: <a href="../brdfs_and_pigments/#Raytracing.SpecularBRDF"><code>SpecularBRDF</code></a>, <a href="#Raytracing.Ray"><code>Ray</code></a>, <a href="#Raytracing.Vec"><code>Vec</code></a>,  <a href="#Raytracing.Point"><code>Point</code></a>, <a href="#Raytracing.Normal"><code>Normal</code></a>, <a href="#Raytracing.PCG"><code>PCG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/Raytracing/blob/b933327db0844de9c9d7e766ae2b172b2b064d03/src/ScatterRay.jl#L72-L105">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../demo_animation/">« Demo animation</a><a class="docs-footer-nextpage" href="../readingwritingpfm/">Reading and Writing PFM files »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 8 June 2021 15:40">Tuesday 8 June 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
